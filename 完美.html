<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>爱心跳动</title>
    <script src="vue.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000000;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #app {
            text-align: center;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: pointer;
        }
        
        .title {
            color: #ff6b81;
            font-size: 32px;
            margin-top: 30px;
            text-shadow: 0 0 10px rgba(255, 107, 129, 0.3);
        }
        
        .hint {
            position: absolute;
            bottom: 20px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="app">
        <canvas ref="heartCanvas" @click="scatterParticles"></canvas>
        <div class="hint">点击屏幕触发散开效果</div>
    </div>

    <script>
        new Vue({
            el: '#app',
            mounted: function() {
                // 设置canvas尺寸为全屏
                this.$refs.heartCanvas.width = window.innerWidth;
                this.$refs.heartCanvas.height = window.innerHeight;
                
                this.initCanvas();
                this.createHeartParticles();
                this.animate();
                
                // 监听窗口大小变化
                window.addEventListener('resize', this.handleResize);
            },
            methods: {
                initCanvas: function() {
                    this.canvas = this.$refs.heartCanvas;
                    this.ctx = this.canvas.getContext('2d');
                    this.particles = [];
                    this.heartbeat = 0;
                    this.scatterPhase = false;
                    this.scatterProgress = 0;
                    this.restoreProgress = 0;
                },
                
                handleResize: function() {
                    // 调整canvas尺寸
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                    // 重新创建粒子
                    this.createHeartParticles();
                },
                
                // 创建心形粒子
                createHeartParticles: function() {
                    const particles = [];
                    const particleCount = 2000;
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height / 2;
                    const size = Math.min(this.canvas.width, this.canvas.height) * 0.25; // 根据屏幕大小自适应
                    
                    // 使用心形方程生成粒子
                    for (let i = 0; i < particleCount; i++) {
                        // 心形参数方程: x = 16sin³(t), y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                        const t = Math.random() * Math.PI * 2;
                        const scale = size / 16;
                        
                        // 生成心形轮廓上的点
                        const x = 16 * Math.pow(Math.sin(t), 3);
                        const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                        
                        // 添加一些内部填充点
                        const distance = Math.random();
                        const innerX = x * distance;
                        const innerY = y * distance;
                        
                        particles.push({
                            x: centerX + innerX * scale,
                            y: centerY + innerY * scale,
                            originalX: centerX + innerX * scale,
                            originalY: centerY + innerY * scale,
                            size: Math.random() * 2 + 1,
                            speed: Math.random() * 0.02 + 0.005,
                            offset: Math.random() * Math.PI * 2,
                            vx: 0,
                            vy: 0,
                            // 散开时的目标位置
                            scatterX: 0,
                            scatterY: 0
                        });
                    }
                    
                    this.particles = particles;
                },
                
                // 散开粒子效果
                scatterParticles: function() {
                    this.scatterPhase = true;
                    this.scatterProgress = 0;
                    this.restoreProgress = 0;
                    
                    // 为每个粒子设置随机的全屏散开位置
                    const padding = 30;
                    for (let i = 0; i < this.particles.length; i++) {
                        const p = this.particles[i];
                        p.scatterX = padding + Math.random() * (this.canvas.width - padding * 2);
                        p.scatterY = padding + Math.random() * (this.canvas.height - padding * 2);
                        
                        // 添加一些不规则效果，让部分粒子飞得更远
                        if (Math.random() > 0.8) {
                            // 一部分粒子靠近边缘
                            if (Math.random() > 0.5) {
                                p.scatterX = Math.random() > 0.5 ? 10 : this.canvas.width - 10;
                            } else {
                                p.scatterY = Math.random() > 0.5 ? 10 : this.canvas.height - 10;
                            }
                        }
                        
                        // 少量粒子随机分布在很远的位置
                        if (Math.random() > 0.95) {
                            p.scatterX = Math.random() * this.canvas.width;
                            p.scatterY = Math.random() * this.canvas.height;
                        }
                    }
                },
                
                // 绘制粒子
                drawParticles: function() {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    // 计算心跳缩放
                    const scale = 1 + Math.sin(this.heartbeat) * 0.1;
                    this.heartbeat += 0.03; // 减慢心跳速度
                    
                    // 处理散开和恢复进度
                    if (this.scatterPhase) {
                        if (this.scatterProgress < 1) {
                            // 正在散开过程中
                            this.scatterProgress += 0.008; // 减慢散开速度
                            if (this.scatterProgress >= 1) {
                                this.scatterProgress = 1;
                            }
                        } else {
                            // 已经散开，正在恢复过程中
                            this.restoreProgress += 0.008; // 减慢恢复速度
                            if (this.restoreProgress >= 1) {
                                // 恢复完成，回到正常心跳状态
                                this.scatterPhase = false;
                                this.restoreProgress = 1;
                            }
                        }
                    }
                    
                    // 绘制每个粒子
                    for (let i = 0; i < this.particles.length; i++) {
                        const p = this.particles[i];
                        
                        let x, y;
                        
                        if (this.scatterPhase) {
                            if (this.scatterProgress < 1) {
                                // 正在散开过程中
                                const progress = this.scatterProgress;
                                // 使用缓动函数让动画更自然
                                const easeProgress = 1 - Math.pow(1 - progress, 4);
                                x = p.x + (p.scatterX - p.x) * easeProgress;
                                y = p.y + (p.scatterY - p.y) * easeProgress;
                            } else {
                                // 已经散开，正在恢复过程中
                                const progress = this.restoreProgress;
                                // 使用缓动函数让动画更自然
                                const easeProgress = 1 - Math.pow(1 - progress, 4);
                                x = p.scatterX + (p.originalX - p.scatterX) * easeProgress;
                                y = p.scatterY + (p.originalY - p.scatterY) * easeProgress;
                            }
                        } else {
                            // 正常心跳阶段
                            const centerX = this.canvas.width / 2;
                            const centerY = this.canvas.height / 2;
                            
                            const dx = p.originalX - centerX;
                            const dy = p.originalY - centerY;
                            
                            const scaledX = centerX + dx * scale;
                            const scaledY = centerY + dy * scale;
                            
                            // 添加轻微的波动效果
                            const wave = Math.sin(this.heartbeat * 2 + p.offset) * 0.5;
                            x = scaledX + wave;
                            y = scaledY + wave;
                        }
                        
                        // 绘制粒子
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, p.size, 0, Math.PI * 2);
                        this.ctx.fillStyle = `rgba(255, 107, 129, ${0.7 + Math.sin(this.heartbeat + p.offset) * 0.3})`;
                        this.ctx.fill();
                    }
                },
                
                // 动画循环
                animate: function() {
                    this.drawParticles();
                    requestAnimationFrame(this.animate);
                }
            }
        });
    </script>
</body>
</html>